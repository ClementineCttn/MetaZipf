IncomeToAllocate = IncomeDistribution[IncomeDistribution$Pick==i,"incomeGroup"]
incomeGroupAllocation = sample(IncomeToAllocate)
for (j in 1:sideMatrix){
incomeGrid[i,j] = incomeGroupAllocation[[j]]
}}
################ Compute segregation index
grd <- GridTopology(cellcentre.offset=c(0.5,0.5),
cellsize=c(1,1), cells.dim=c(sideMatrix,sideMatrix))
grd.sp <- as.SpatialPolygons.GridTopology(grd)
incomeFrame = melt(incomeGrid)
colnames(incomeFrame) = c("x", "y", "incomeGroup")
for (i in 1:nGroups){
incomeFrame[,3+i] = ifelse(incomeFrame$incomeGroup == i, 1, 0)
colnames(incomeFrame)[3+i] = paste("Group", i, sep="_")
}
cols = seq (4,3+nGroups, 1)
segRes = spseg(x = grd.sp, data = incomeFrame[,cols], smoothing = Smoothing)
print(segRes, digits = 3)
print(gini, digits = 3)
spplot(segRes)#, main = "No spatial smoothing")
segI = c(segRes@d, segRes@r, segRes@h)
################ Visualise spatial distribution
#vizGrid(incomeGrid, breaks, round(segI[[segregationI]],2), slopeIncome = slopeIncome)
################################################
#
#     Income Inequality & Income Segregation
#         Clementine _ 18 September 2015
#
################################################
library(lattice)
library(RColorBrewer)
library(seg)
library(reshape2)
library(dplyr)
library(data.table)
vizGrid = function(initialGrid, breaks = breaks, segI = "", slopeIncome,
my_palette = colorRampPalette(c("darkorange", "floralwhite"))(n = 299)) {
levelplot(initialGrid, col.regions=my_palette, at=breaks,
xlab = "", ylab="", main = paste("Inequality Level: ", slopeIncome," | Segregation Level: ", segI, sep=""),
colorkey=T, scales=list(draw=F))
}
cumulativeFrequency = function(distribution){
relativeDistribution = distribution / sum(distribution)
iterator = length(distribution) - 1
cumulativeRelative = seq(1:iterator)
for (i in 1:iterator){
if (i == 1) cumulativeRelative[[i]] = relativeDistribution[[i]]
if (i != 1) {
cumulativeRelative[[i]] = cumulativeRelative[[i-1]] +  relativeDistribution[[i]]
}}
return(cumulativeRelative)
}
Lorenz = function(I_Distribution, N_Distribution){
groups = length(N_Distribution)
cum_N_Distribution =  c(0,cumulativeFrequency(N_Distribution), 1)
cum_I_Distribution = c(0,cumulativeFrequency(I_Distribution), 1)
# plot(cum_N_Distribution, cum_I_Distribution)
lorenzTable = data.frame(cum_N_Distribution, cum_I_Distribution)
colnames(lorenzTable) = c("x", "y")
rownames(lorenzTable) = c(0:groups)
return(lorenzTable)
}
giniGrouped = function(I_Distribution, N_Distribution, I_Bounds){
Nk = sumNum(N_Distribution)
Ak = sumNum(I_Distribution)
LP = Lorenz(I_Distribution, N_Distribution)
LP$z = c(Bounds,NA) # upper class boundary
LP$r =  LP$z / (Ak / Nk)
groups = length(I_Distribution)
iterator = groups - 1
toSum = seq(1:groups)
for (i in 1:groups){
I = as.character(i)
J = as.character(i - 1)
toSum[[i]] = (LP[J,"x"] * LP[I,"y"]) - (LP[I,"x"] * LP[J,"y"])
}
GL = sum(toSum)
gToSum = seq(1:groups)
for (i in 1:iterator){
I = as.character(i)
J = as.character(i - 1)
gToSum[[i]] = ( (LP[I,"y"] - LP[J,"y"]) - ( LP[J,"r"] * (LP[I,"x"] - LP[J,"x"]))) *
((LP[I,"r"] * (LP[I,"x"] - LP[J,"x"] )) - (LP[I,"y"] - LP[J,"y"] )) / (LP[I,"r"] - LP[J,"r"])
}
K = as.character(groups)
gToSum[[groups]] = ((LP[K,"y"] - LP[I,"y"]) - (LP[I,"r"] * (LP[K,"x"] - LP[I,"x"]))) *  (LP[K,"x"] - LP[I,"x"])
g = sum(gToSum)
GU = GL + g
gini = GL + (0.5 * g)
gini=data.frame(c("GL", "GU", "g", "gini"), c(GL, GU, g, gini))
colnames(gini) = c("index", "value")
return(gini)
}
segFunction2 = function(distribution){
ordinalVariationIndexR = 4 * distribution * ( 1 - distribution)
return(ordinalVariationIndexR)
}
segIndex = function(com, M_Cols){
DistribCluster = colSums(com[,M_Cols], na.rm = T)
Tcluster = sum(DistribCluster)
cumulativeDistributionCluster = cumulativeFrequency(DistribCluster)
com$t = rowSums(com[,M_Cols], na.rm = T)
M_Col = M_Cols[1:(K-1)]
RelM_Cols = paste("Rel",M_Col, sep="")
CumM_Cols = paste("Cum",M_Col, sep="")
MSeg_Cols = paste("Seg", M_Col, sep="")
com[,RelM_Cols] = com[,M_Col] / com$t
com[,CumM_Cols[1]] = com[,RelM_Cols[1]]
com[,CumM_Cols[2]] = com[,RelM_Cols[2]] + com[,CumM_Cols[1]]
com[,CumM_Cols[3]] = com[,RelM_Cols[3]] + com[,CumM_Cols[2]]
com[,CumM_Cols[4]] = com[,RelM_Cols[4]] + com[,CumM_Cols[3]]
com[,CumM_Cols[5]] = com[,RelM_Cols[5]] + com[,CumM_Cols[4]]
com[,CumM_Cols[6]] = com[,RelM_Cols[6]] + com[,CumM_Cols[5]]
com[,CumM_Cols[7]] = com[,RelM_Cols[7]] + com[,CumM_Cols[6]]
com[,MSeg_Cols] = segFunction2(com[,CumM_Cols])
com$v = (1 / (K - 1)) * rowSums(com[,MSeg_Cols], na.rm = T)
Vcluster = (1 / (K - 1)) * sum(segFunction2(cumulativeDistributionCluster))
com$seg = (com$t / (Tcluster * Vcluster)) * (Vcluster - com$v)
segIndex = sum(com$seg, na.rm = T)
return(segIndex)
}
############### PARAMETERS
slopeIncome = 0.4
nPeople = 1000
nGroups = 4
segregationIndex = "Entropy"
Smoothing = "kernel"
############### Initialisation
sideMatrix = floor(sqrt(nPeople))
nPeople = sideMatrix^2
totalWealthBreaks = seq(1 / nGroups, 1 - (1 / nGroups), 1 / nGroups) # 1 = richest, 2 = less rich, 3 = poorer, ...
incomeGrid = matrix(ncol=sideMatrix, nrow=sideMatrix)
IncomeDistribution = data.frame(relativeIncome=nPeople, cumulativeIncome=nPeople)
breaks = seq(0, nGroups, 1)
if (segregationIndex == "Dissimilarity") segregationI = 1
if (segregationIndex == "Reardon") segregationI = 2
if (segregationIndex == "Entropy") segregationI = 3
################ Distribution generation
for (i in 1:nPeople){
IncomeDistribution[i,1] = 100 * i ^ (-1 * slopeIncome)
IncomeDistribution[i,2] = ifelse(i > 1, IncomeDistribution[i-1,2] + IncomeDistribution[i,1], IncomeDistribution[i,1])
}
TotalIncome = sum(IncomeDistribution$relativeIncome)
IncomeDistribution$relativeCumulative = IncomeDistribution$cumulativeIncome / TotalIncome
IncomeDistribution[IncomeDistribution$relativeCumulative <= totalWealthBreaks[[1]], "incomeGroup"] = 1
for (i in 1:length(totalWealthBreaks)){
IncomeDistribution[IncomeDistribution$relativeCumulative > totalWealthBreaks[[i]], "incomeGroup"] = i+1
}
IncomeDistribution$ID = 1:nPeople
IncomeDistribution$Pick = 0
################ Compute Inequality index
#I_Bounds_Gen = c(0, 1, 5, 10, 20, 50)
I_Bounds_Gen = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100.1)
bins = length(I_Bounds_Gen) - 1
Bounds = I_Bounds_Gen[1:bins]
IncomeDistribution$Class = cut(IncomeDistribution$relativeIncome, I_Bounds_Gen, right=F)
N_Distribution =  data.frame(table(IncomeDistribution$Class))
I_Distribution = aggregate(x = IncomeDistribution[,"relativeIncome"],
by = list(IncomeDistribution$Class), FUN = sumNum)
Dists = merge(N_Distribution, I_Distribution, by.x="Var1", by.y="Group.1", all.x=T)
colnames(Dists) = c("Group", "N", "Income")
Dists[is.na(Dists)] <- 0
giniI = giniGrouped(N_Distribution = Dists[,"N"],
I_Distribution = Dists[,"Income"],
I_Bounds = Bounds)
gini = giniI[4,2]
################ Spatial allocation
for (i in 1:sideMatrix){
possibleIDs = IncomeDistribution[IncomeDistribution$Pick==0,"ID"]
chosenIDs = sample(possibleIDs, sideMatrix, replace = FALSE)
IncomeDistribution$Pick = ifelse(IncomeDistribution$ID %in% chosenIDs, i, 0)
IncomeToAllocate = IncomeDistribution[IncomeDistribution$Pick==i,"incomeGroup"]
incomeGroupAllocation = sample(IncomeToAllocate)
for (j in 1:sideMatrix){
incomeGrid[i,j] = incomeGroupAllocation[[j]]
}}
################ Compute segregation index
grd <- GridTopology(cellcentre.offset=c(0.5,0.5),
cellsize=c(1,1), cells.dim=c(sideMatrix,sideMatrix))
grd.sp <- as.SpatialPolygons.GridTopology(grd)
incomeFrame = melt(incomeGrid)
colnames(incomeFrame) = c("x", "y", "incomeGroup")
for (i in 1:nGroups){
incomeFrame[,3+i] = ifelse(incomeFrame$incomeGroup == i, 1, 0)
colnames(incomeFrame)[3+i] = paste("Group", i, sep="_")
}
cols = seq (4,3+nGroups, 1)
segRes = spseg(x = grd.sp, data = incomeFrame[,cols], smoothing = Smoothing)
print(segRes, digits = 3)
print(gini, digits = 3)
spplot(segRes)#, main = "No spatial smoothing")
segI = c(segRes@d, segRes@r, segRes@h)
################ Visualise spatial distribution
#vizGrid(incomeGrid, breaks, round(segI[[segregationI]],2), slopeIncome = slopeIncome)
segRes
spplot(segRes)#, main = "No spatial smoothing")
library(lattice)
library(RColorBrewer)
library(seg)
library(reshape2)
library(dplyr)
library(data.table)
spplot(segRes)#, main = "No spatial smoothing")
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
nestim = 3
form = function(nestim) {
chain = 'wellPanel(column(6,numericInput(paste("alphaestim", nestim) , paste("Alpha", nestim) , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)'
return(chain)
}
#  }
FinalChain = form(1)
pasteInputs = function(chainInputs){
chain = paste(chainInputs,'wellPanel(column(6,numericInput(paste("alphaestim", i) , paste("Alpha", i) , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))', sep=",")
return(chain)
}
if (nestim > 1){
repetitions = nestim - 1
FinalChain = do.call(`paste0`,as.data.frame(replicate(repetitions, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
FinalChain
str(FinalChain)
shiny::runApp('Documents/MetaZipf')
final = parse(text = FinalChain)
FinalChain
shiny::runApp('Documents/MetaZipf')
form = function(nestim) {
chain = paste('wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep ="")
return(chain)
}
#  }
FinalChain = form(1)
pasteInputs = function(chainInputs){
chain = paste(chainInputs, ',', 'wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep="")
return(chain)
}
if (nestim > 1){
repetitions = nestim - 1
FinalChain = do.call(`paste0`,as.data.frame(replicate(repetitions, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
final = parse(text = FinalChain)
FinalChain
final = parse(text = FinalChain)
str(FinalChain)
FinalChain[1]
FinalChain[2]
nestim = 2
form = function(nestim) {
chain = paste('wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep ="")
return(chain)
}
#  }
FinalChain = form(1)
pasteInputs = function(chainInputs){
chain = paste(chainInputs, ',', 'wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep="")
return(chain)
}
if (nestim > 1){
repetitions = nestim - 1
FinalChain = do.call(`paste0`,as.data.frame(replicate(repetitions, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
final = parse(text = FinalChain)
FinalChain
str(FinalChain)
nestim = 6
if (nestim > 1){
repetitions = nestim - 1
FinalChain = do.call(`paste0`,as.data.frame(replicate(repetitions, pasteInputs(chainInputs = FinalChain))))
}
final = parse(text = FinalChain)
str(FinalChain)
nestim = 6
form = function(nestim) {
chain = paste('wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep ="")
return(chain)
}
#  }
#FinalChain = form(1)
pasteInputs = function(chainInputs){
chain = paste(chainInputs, ',', 'wellPanel(column(6,numericInput(paste("alphaestim",', nestim,') , paste("Alpha",', nestim, ') , value = "1")),
column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
column(4,numericInput("r2estim", "R2", value = "100"))
)', sep="")
return(chain)
}
FinalChain = ""
if (nestim >= 1){
FinalChain = do.call(`paste0`,as.data.frame(replicate(nestim, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
final = parse(text = FinalChain)
str(FinalChain)
FinalChain = "'go'"
if (nestim >= 1){
FinalChain = do.call(`paste0`,as.data.frame(replicate(nestim, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
final = parse(text = FinalChain)
FinalChain = "wellPanel('go')"
if (nestim >= 1){
FinalChain = do.call(`paste0`,as.data.frame(replicate(nestim, pasteInputs(chainInputs = FinalChain))))
}
# for (i in 1:nestim){
#   textInput(paste("estim", i, sep="_"), paste("Estimate N.", i, sep=" "), value="Bingo ?")
# }
final = parse(text = FinalChain)
FinalChain
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
makePanel = function(x){fluidRow(column(6,numericInput(paste("alphaestim", x) , paste("Alpha",x) , value = "1"))
#                                          ,
#             column(6,numericInput("dateestim", "Date of estimation", value = "2000")),
#             column(6,textInput("urbandefestim", "Urban Definition", value = "Ex: SMA, Boroughs, UN agglomerations...")),
#             column(6,numericInput("truncestim", "Minimum Population of Cities", value = "10000")),
#             column(4,numericInput("nCitiesestim", "Number of cities", value = "100")),
#             column(4,textInput("territoryestim", "Territory", value = "Ex: France")),
#             column(4,numericInput("r2estim", "R2", value = "100"))
)
}
makePanel(2)
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
pastePanels = function(panel, i) {
newPanel = paste(panel, makePanel(i), sep=",")
return(newPanel)
}
panel = makePanel(1)
panel
newPanel = (panel, 2)
newPanel = pastePanels(panel, 2)
newPanel
parse(newPanel)
pastePanels = function(panel, i) {
newPanel = paste(panel, makePanel(i), sep="\n")
return(newPanel)
}
panel = makePanel(1)
newPanel = pastePanels(panel, 2)
parse(newPanel)
p = parse(newPanel)
newPanel
parse(newPanel)
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
shiny::runApp('Documents/MetaZipf')
setwd("~/Documents/MetaZipf")
shiny::runApp()
shiny::runApp('~/Documents/VARIUS-master')
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
