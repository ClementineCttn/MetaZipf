<<<<<<< HEAD
head(prarm)
head(param)
unique(paramå,1)
unique(param,1)
unique(param[,1])
#indics=c("accessibility","entropy","stability","travel-distance")
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in indics_cols_toplot){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = i,
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[i]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[i])
}
multiplot(plotlist=plotlist,cols=3)
}
unique(param[,1])
unique(param[,3])
unique(param[,4])
unique(param[,5])
unique(param[,6])
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in indics_cols_toplot){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = i,
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[i]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[i])
}
multiplot(plotlist=plotlist,cols=3)
}
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in indics_cols_toplot){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = i,
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[i]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[i])
}
multiplot(plotlist=plotlist,cols=3)
}
plotWithBars<-function(param,mean,sd,fixed_par_cols,fixed_par_vals,fixed_par_thresholds,indicator,x_param,varying_param,xlab,ylab){
# get concerned rows
rows=rep(TRUE,nrow(param))
for(k in 1:length(fixed_par_cols)){rows=rows&(abs(param[,fixed_par_cols[k]]-fixed_par_vals[k])<fixed_par_thresholds[k]); }
p=ggplot(data.frame(x=param[rows,x_param],
y=mean[rows,indicator],
group=param[rows,varying_param],
ymin=mean[rows,indicator]-sd[rows,indicator],
ymax=mean[rows,indicator]+sd[rows,indicator]),
aes(x=x,y=y,colour=group))
p+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(xlab)+ylab(ylab)
return(p)
}
#indics=c("accessibility","entropy","stability","travel-distance")
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in indics_cols_toplot){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = i,
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[i]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[i])
}
multiplot(plotlist=plotlist,cols=3)
}
head(mean)
x
i
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in 1:length(indics_cols_toplot)){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = indics_cols_toplot[i],
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[indics_cols_toplot[i]]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[indics_cols_toplot[i]])
}
multiplot(plotlist=plotlist,cols=3)
}
res <- read.csv('Models/Governance/MetropolSim/MetropolSim3/res_oml/2015_09_03_16_28_04_grid.csv',sep=",",header=TRUE)
params_cols = c(3,4,6,9,11,12,14,18)
indics_cols = c(1,2,5,7,8,10,13,15,16,17)
raw = getSingleParamPoints(
data = res,
params_cols = params_cols,
indics_cols = indics_cols
)
param=matrix(data=unlist(raw$param),ncol=length(params_cols),byrow=TRUE);colnames(param)<-colnames(res)[params_cols]
mean=matrix(data=unlist(raw$mean),ncol=length(indics_cols),byrow=TRUE);colnames(mean)<-colnames(res)[indics_cols]
sd=matrix(data=unlist(raw$sd),ncol=length(indics_cols),byrow=TRUE);colnames(sd)<-colnames(res)[indics_cols]
plotWithBars<-function(param,mean,sd,fixed_par_cols,fixed_par_vals,fixed_par_thresholds,indicator,x_param,varying_param,xlab,ylab){
# get concerned rows
rows=rep(TRUE,nrow(param))
for(k in 1:length(fixed_par_cols)){rows=rows&(abs(param[,fixed_par_cols[k]]-fixed_par_vals[k])<fixed_par_thresholds[k]); }
p=ggplot(data.frame(x=param[rows,x_param],
y=mean[rows,indicator],
group=param[rows,varying_param],
ymin=mean[rows,indicator]-sd[rows,indicator],
ymax=mean[rows,indicator]+sd[rows,indicator]),
aes(x=x,y=y,colour=group))
p+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(xlab)+ylab(ylab)
return(p)
}
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in 1:length(indics_cols_toplot)){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = indics_cols_toplot[i],
x_param = xpars[x],
varying_param =  4,
xlab=colnames(vpar)[x],ylab=indics[indics_cols_toplot[i]]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[indics_cols_toplot[i]])
}
multiplot(plotlist=plotlist,cols=3)
}
x
i
plotlist
res <- read.csv('Models/Governance/MetropolSim/MetropolSim3/res_oml/2015_09_03_16_28_04_grid.csv',sep=",",header=TRUE)
library(ggplot2)
source(paste0(Sys.getenv("CN_HOME"),'/Models/Utils/R/plots.R'))
res <- read.csv('Models/Governance/MetropolSim/MetropolSim3/res_oml/2015_09_03_16_28_04_grid.csv',sep=",",header=TRUE)
dim(res)
params_cols = c(3,4,6,9,11,12,14,18)
indics_cols = c(1,2,5,7,8,10,13,15,16,17)
raw = getSingleParamPoints(
data = res,
params_cols = params_cols,
indics_cols = indics_cols
)
param=matrix(data=unlist(raw$param),ncol=length(params_cols),byrow=TRUE);colnames(param)<-colnames(res)[params_cols]
mean=matrix(data=unlist(raw$mean),ncol=length(indics_cols),byrow=TRUE);colnames(mean)<-colnames(res)[indics_cols]
sd=matrix(data=unlist(raw$sd),ncol=length(indics_cols),byrow=TRUE);colnames(sd)<-colnames(res)[indics_cols]
dim(param)
dim(mean)
353 * 7
res <- read.csv('Models/Governance/MetropolSim/MetropolSim3/res_oml/2015_09_02_21_08_33_grid.csv',sep=",",header=TRUE)
params_cols = c(3,4,6,9,11,12,14,18)
indics_cols = c(1,2,5,7,8,10,13,15,16,17)
raw = getSingleParamPoints(
data = res,
params_cols = params_cols,
indics_cols = indics_cols
)
param=matrix(data=unlist(raw$param),ncol=length(params_cols),byrow=TRUE);colnames(param)<-colnames(res)[params_cols]
mean=matrix(data=unlist(raw$mean),ncol=length(indics_cols),byrow=TRUE);colnames(mean)<-colnames(res)[indics_cols]
sd=matrix(data=unlist(raw$sd),ncol=length(indics_cols),byrow=TRUE);colnames(sd)<-colnames(res)[indics_cols]
plotWithBars<-function(param,mean,sd,fixed_par_cols,fixed_par_vals,fixed_par_thresholds,indicator,x_param,varying_param,xlab,ylab){
# get concerned rows
rows=rep(TRUE,nrow(param))
for(k in 1:length(fixed_par_cols)){rows=rows&(abs(param[,fixed_par_cols[k]]-fixed_par_vals[k])<fixed_par_thresholds[k]); }
p=ggplot(data.frame(x=param[rows,x_param],
y=mean[rows,indicator],
group=param[rows,varying_param],
ymin=mean[rows,indicator]-sd[rows,indicator],
ymax=mean[rows,indicator]+sd[rows,indicator]),
aes(x=x,y=y,colour=group))
p+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(xlab)+ylab(ylab)
return(p)
}
#indics=c("accessibility","entropy","stability","travel-distance")
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in 1:length(indics_cols_toplot)){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = indics_cols_toplot[i],
x_param = xpars[x],
varying_param = 4,
xlab=colnames(vpar)[x],ylab=indics[indics_cols_toplot[i]]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[indics_cols_toplot[i]])
}
multiplot(plotlist=plotlist,cols=3)
}
#indics=c("accessibility","entropy","stability","travel-distance")
indics=colnames(mean)
indics_cols_toplot = c(1,2,3,4,5,8,9)
vpar=param[,c(1,3,4,5,6)]
plotlist=list();
xpars=c(1,2,3,5);fixedxpars=c(1.1e-4,4,9,0.006)
for(x in 1:length(xpars)){
for(i in 1:length(indics_cols_toplot)){
plotlist[[i]]=
plotWithBars(
param = vpar,mean=mean,sd=sd,
fixed_par_cols = xpars[-x],
fixed_par_vals = fixedxpars[-x],
fixed_par_thresholds = rep(1e-5,3),
indicator = indics_cols_toplot[i],
x_param = xpars[x],
varying_param = 4,
xlab=colnames(vpar)[x],ylab=indics[indics_cols_toplot[i]]
)+geom_point()+geom_errorbar(aes(x=x,ymin=ymin,ymax=ymax))+xlab(colnames(vpar)[xpars[x]])+ylab(indics[indics_cols_toplot[i]])
}
multiplot(plotlist=plotlist,cols=4)
}
library(RColorBrewer)
library(ggplot2)
library(MASS)
source(paste0(Sys.getenv('CN_HOME'),'/Models/Utils/R/plots.R'))
# data
real_raw = read.csv(
paste0(Sys.getenv("CN_HOME"),'/Results/Morphology/Density/Numeric/20150806_europe50km_10kmoffset_100x100grid.csv'),
sep=";"
)
real =real_raw[!is.na(real_raw[,3])&!is.na(real_raw[,4])&!is.na(real_raw[,5])&!is.na(real_raw[,6])&!is.na(real_raw[,7])&!is.na(real_raw[,8])&!is.na(real_raw[,9]),]
# hists
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","log-normal","normal","normal")
ranges=list((1:250)/1000,(1:100)/1000,(600:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(rev(real[[indic]]),"log-normal"))
dens=rev(dnorm(ranges[[k]],mean=fit[1],sd=fit[2]))
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
summary(real)
summary(real$distance)
hist(real$distance,breaks = 500)
h=hist(real$distance,breaks = 500)
h
help(bar)
help(bars)
plot(rev(h$mids),rev(h$density))
plot(h$mids,rev(h$density))
help(fitdistr)
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
ranges=list((1:250)/1000,(1:100)/1000,(600:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]],"log-normal"))
dens=rev(dnorm(ranges[[k]],mean=fit[1],sd=fit[2]))
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
# hists
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
ranges=list((1:250)/1000,(1:100)/1000,(600:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=rev(dnorm(ranges[[k]],mean=fit[1],sd=fit[2]))
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
ranges=list((1:250)/1000,(1:1000)/1000,(600:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=rev(dnorm(ranges[[k]],mean=fit[1],sd=fit[2]))
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
# hists
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
ranges=list((1:250)/1000,(1:1000)/1000,(600:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
#hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
hist(
max(real[indic]) - real[[indic]]+1e-4,breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=rev(dnorm(ranges[[k]],mean=fit[1],sd=fit[2]))
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
# hists
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
ranges=list((1:250)/1000,(1:1000)/1000,(1:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
#hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
hist(
max(real[indic]) - real[[indic]]+1e-4,breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
# hists
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
#laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
laws=rep("",4)
ranges=list((1:250)/1000,(1:1000)/1000,(1:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
#hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
par(mfrow=c(2,2))
indics=c("moran","distance","entropy","slope");
#laws=c("log-normal","inv-log-normal","inv-log-normal","normal")
laws=rep("",4)
ranges=list((1:250)/1000,(1:1000)/1000,(1:1000)/1000,(-2500:-500)/1000)
k=1
for(indic in indics){
#hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
hist(real[[indic]],breaks=500,main="",xlab=indic,freq=FALSE)
if(laws[k]=="log-normal"){
fit = coef(fitdistr(abs(real[[indic]]),laws[k]))
dens=dlnorm(ranges[[k]],meanlog=fit[1],sdlog=fit[2])#*sign(fit[1])
}
if(laws[k]=="inv-log-normal"){
# fit on inversed distrib in that case
fit = coef(fitdistr(max(real[indic]) - real[[indic]]+1e-4,"log-normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
if(laws[k]=="normal"){
fit = coef(fitdistr(real[[indic]],"normal"))
dens=dnorm(ranges[[k]],mean=fit[1],sd=fit[2])
}
#points(ranges[[k]],dens,type="l",col="red")
k=k+1
}
###############
#
help(install.packages)
library(test)
help(test)
rcpp_hello_world()
rcpp_hello_world()
help(CMD)
help(INSTALL)
help(.Ca)
help(.Call)
library(seg)
install.packages("seg")
library(seg)
help(seg)
setwd('~/Documents/ComplexSystems/MetaZipf')
list.files()
refs = read.csv('data/zipf_refs.csv')
refs
dim(refs)
meta = read.csv('data/zipf_meta.csv')
meta
head(meta)
head(refs)
write.csv(data.frame(id=1:nrow(refs),refs),'data/refs_id.csv')
help(write.csv)
write.csv(data.frame(id=1:nrow(refs),refs),'data/refs_id.csv',quote=FALSE)
write.csv(data.frame(id=1:nrow(refs),refs),'data/refs_id.csv',quote=FALSE,row.names=FALSE)
=======
plot(testedHoles)
testedHoles
str(testedHoles)
testedHoles@polygons[[1]]@hole
testedHoles@polygons[[1]]
testedHoles@polygons[[]]
testedHoles@polygons[[1]]@Polygons[[1]]@hole
testedHoles@polygons[[2]]@Polygons[[1]]@hole
testedHoles@polygons[[1]]@Polygons[[2]]@hole
testedHoles@polygons[[1]]@Polygons[[3]]@hole
testedHoles@polygons[[1]]@Polygons[[4]]@hole
testedHoles@polygons[[1]]@Polygons[[5]]@hole
testedHoles@polygons[[3]]@Polygons[[5]]@hole
testedHoles@polygons[[1]]@Polygons[[10]]@hole
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]@hole == TRUE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]@hole == FALSE]
plot(tt)
testedHoles@polygons[[1]]@Polygons[[1]]@hole
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[2]]@hole == FALSE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[3]]@hole == FALSE]
plot(tt)
testedHoles@polygons[[1]]@Polygons
dim(testedHoles@polygons[[1]]@Polygons)
length(testedHoles@polygons[[1]]@Polygons)
(testedHoles@polygons[[1]]@Polygons[[1]])
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[2]]]
plot(tt)
(testedHoles@polygons[[1]]@Polygons[[2]])
tt = testedHoles@polygons[[1]]@Polygons[[2]]
plot(tt)
tt
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[3]]@hole == FALSE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[2]]@hole == FALSE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]@hole == FALSE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]@hole == FALSE]
plot(tt)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1]]@hole == FALSE]
plot(tt, col = "red")
(testedHoles@polygons[[1]]@Polygons[[2]])
testedHoles@polygons[[1]]@Polygons[[2]]@hole
testedHoles@polygons[[1]]@Polygons[[3]]@hole
testedHoles@polygons[[1]]@Polygons[[2]]@hole
testedHoles@polygons[[1]]@Polygons[[1]]@hole
testedHoles@polygons[[1]]@Polygons[[19]]@hole
tt = testedHoles[testedHoles@polygons[[1]]@Polygons@hole == TRUE]
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1:19]]@hole == TRUE]
testedHoles@polygons = lapply(testedHoles@polygons, function(x) { x@Polygons = x@Polygons[1]; x})
plot(data[data$IndID == "MTG_005_A",])
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
sp::Polygons(noHoles, ID = poly@ID)
}
)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
setGeneric('dropHole',def=function(poly, ...){
standardGeneric('dropHole')
})
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
sp::Polygons(noHoles, ID = poly@ID)
}
)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
newmap <- dropHole(NSWACTA)
tt = testedHoles[testedHoles@polygons[[1]]@Polygons[[1:19]]@hole == TRUE]
plot(tt, col = "red")
newmap <- dropHole(testedHoles)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
newmap <- dropHole(testedHoles)
str(testedHoles)
testedHoles.df = as.data.frame("ID" = 1075)
testedHoles.df = data.frame("ID" = 1075)
testedHoles.df
testedHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
rownames(testedHoles.df)
testedHoles@polygons[[1]]@ID
rownames(testedHoles.df) = testedHoles.df$ID
testedHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
newmap <- dropHole(testedHoles)
str(testedHoles)
testingHoles = wpp[!is.na(wpp@data$IDNP),]
testingHoles = testingHoles[testingHoles@data$IDNP == 1075,]
testedHoles = unionSpatialPolygons(testingHoles, testingHoles@data$IDNP)
testedHoles.df = data.frame("ID" = 1075)
rownames(testedHoles.df) = testedHoles.df$ID
withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
str(withHoles)
newmap <- dropHole(withHoles)
# Drop a single sp::Polygon if it is holey
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
setGeneric('dropHole',def=function(poly, ...){
standardGeneric('dropHole')
})
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
sp::Polygons(noHoles, ID = poly@ID)
}
)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
newmap <- dropHole(withHoles)
withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
newmap <- dropHole(withHoles)
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
setGeneric('dropHole',def=function(poly, ...){
standardGeneric('dropHole')
})
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
setGeneric('dropHole',def=function(poly, ...){
standardGeneric('dropHole')
})
# Drop a single sp::Polygon if it is holey
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
sp::Polygons(noHoles, ID = poly@ID)
}
)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
newmap <- dropHole(withHoles)
}
})
setGeneric('dropHole',def=function(poly, ...){
standardGeneric('dropHole')
})
setMethod('dropHole',signature=signature('Polygon'),
def=function(poly) {
#return only Polygons which are not holes
if (poly@hole) NULL else poly
}
)
# Drop holey sp::Polygon entries in the @Polygons list of an sp::Polygons class
setMethod('dropHole', signature = signature('Polygons'),
def = function(poly) {
noHoles <- lapply(poly@Polygons, dropHole)
#Remove the NULL entries from the list
noHoles <- Filter(Negate(is.null), noHoles)
# Turn back into a (single) Polygons
# The generator function (sp::Polygons) fills in the other slots!
# return the new sp:Polygons object
sp::Polygons(noHoles, ID = poly@ID)
}
)
# Drop holey parts of sp::Polygons in the @polygons list
# of an sp::SpatialPolygonsDataFrame
setMethod('dropHole', signature = signature('SpatialPolygonsDataFrame'),
def = function(poly) {
noHoles <- lapply(poly@polygons, dropHole)
# Put the un holey Polygons list back into the @polygons slot
poly@polygons <- noHoles
#return the modified SpatialPolygonsDataFrame
poly
}
)
newmap <- dropHole(withHoles)
plot(newmap)
noHoles <- dropHole(withHoles)
str(noHoles)
rownames(wpp@data) = wpp@data$WZ11CD
testingHoles = wpp[!is.na(wpp@data$IDNP),]
#testingHoles = testingHoles[testingHoles@data$IDNP == 1075,]
testedHoles = unionSpatialPolygons(testingHoles, testingHoles@data$IDNP)
plot(testedHoles)
testedHoles@polygons
length(testedHoles@polygons)
length( testingHoles@data$IDNP)
length( unique(testingHoles@data$IDNP))
testedHoles.df = data.frame("ID" = unique(testingHoles@data$IDNP))
rownames(testedHoles.df) = testedHoles.df$ID
withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
noHoles <- dropHole(withHoles)
plot(noHoles)
writeOGR(noHoles, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHoles.shp", layer = "clusters_NoHoles", driver="ESRI Shapefile")
wpp = poly.data
#wpp = poly.data[poly.data@data$row %in% 45000:48000,]
wpp@data$DNP = (wpp@data$WP607EW0008 + wpp@data$WP607EW0010 +
wpp@data$WP607EW0014 + wpp@data$WP607EW0016) / wpp@data$WP102EW0002
summary(wpp@data$DNP)
cutoff = 2
#wpp@data$row = as.numeric(rownames(wpp@data))
wpp@data$IDNP = ifelse(wpp@data$DNP >= cutoff, 0, NA)
summary(wpp@data$IDNP)
aboveCutoffRows = wpp@data[!is.na(wpp@data$IDNP),"row"]
aboveCutoff = wpp[wpp@data$row %in% aboveCutoffRows,]
head(aboveCutoff)
#plot(aboveCutoff, col="blue", border=F)
id = 0
#r = aboveCutoffRows[100]
#wpp@data[r,]
zonesWithID = c()
for (r in aboveCutoffRows){
print(r)
if (wpp@data[wpp@data$row == r,"IDNP"] == 0) {
id = id + 1
wpp@data[wpp@data$row == r,"IDNP"] = id
#   print("me id-ied")
zonesWithID = unique(c(zonesWithID, r))
myNbRows = nb[r+1][[1]] -1# list neighbours of polygon r (+1 because counting starts from 0 in nb file)
myNbRowsAboveCutoff = myNbRows[myNbRows %in% aboveCutoffRows == TRUE]
theirNeighboursWithoutIDAboveCutoff = myNbRowsAboveCutoff[myNbRowsAboveCutoff %in% zonesWithID == FALSE]
if (length(theirNeighboursWithoutIDAboveCutoff) == 0) theirNeighboursWithoutIDAboveCutoff = NULL
while(!is.null(theirNeighboursWithoutIDAboveCutoff)){
#   print("neighbourhgs id-ied")
wpp@data[wpp@data$row %in% theirNeighboursWithoutIDAboveCutoff ,"IDNP"] = id
zonesWithID = unique(c(zonesWithID, theirNeighboursWithoutIDAboveCutoff))
listNeighbourgs = theirNeighboursWithoutIDAboveCutoff
theirNeighbours = unique(unlist(nb[listNeighbourgs + 1]) - 1) #(+1 because counting starts from 0 in nb file)
theirNeighboursAboveCutoff = theirNeighbours[theirNeighbours %in% aboveCutoffRows == TRUE]
theirNeighboursWithoutIDAboveCutoff = theirNeighboursAboveCutoff[theirNeighboursAboveCutoff %in% zonesWithID == FALSE]
if (length(theirNeighboursWithoutIDAboveCutoff) == 0) theirNeighboursWithoutIDAboveCutoff = NULL
}
}
}
########## Integrating holes now...
#
# underCutoffRows = wpp@data[is.na(wpp@data$IDNP),"row"]
# underCutoff = wpp[wpp@data$row %in% underCutoffRows,]
#
# for (h in underCutoffRows){
#   print(h)
#   myNbRows = nb[h+1][[1]] -1# list neighbours of polygon r (+1 because counting starts from 0 in nb file)
#   myIds = wpp@data[wpp@data$row %in% myNbRows,"IDNP"]
#   if(NA %in% myIds) {} else {
#    if (isTRUE(all.equal(myIds, rep(myIds[1], length(myIds)))) ) {
#      wpp@data[wpp@data$row == h,"IDNP"] = myIds[1]
#    }
#   }
# }
#writeOGR(wpp,"/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clustersTEST.shp", layer = "clustersTEST", driver="ESRI Shapefile")
rownames(wpp@data) = wpp@data$WZ11CD
testingHoles = wpp[!is.na(wpp@data$IDNP),]
#testingHoles = testingHoles[testingHoles@data$IDNP == 1075,]
testedHoles = unionSpatialPolygons(testingHoles, testingHoles@data$IDNP)
testedHoles.df = data.frame("ID" = unique(testingHoles@data$IDNP))
rownames(testedHoles.df) = testedHoles.df$ID
withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
noHoles <- dropHole(withHoles)
plot(noHoles)
str(noHoles)
writeOGR(noHoles, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHoles2.shp", layer = "clusters_NoHoles2", driver="ESRI Shapefile")
t1 = gBuffer(noHoles, byid=FALSE, id=NULL, width=1.0, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(t1)
writeOGR(t1, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf.shp", layer = "clusters_NoHolesBuf", driver="ESRI Shapefile")
str(t1)
t1@polygons
t1@polygons[[1]]
t1@polygons[[1]]@ID
t1@polygons[[2]]@ID
length(t1)
plot(t1, border=F)
plot(t1, border=F, col="red")
t1 = gBuffer(noHoles, byid=TRUE, width=1.0, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
testedHoles.df = data.frame("ID" = unique(testingHoles@data$IDNP))
rownames(testedHoles.df) = testedHoles.df$ID
withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
writeOGR(t1, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf.shp", layer = "clusters_NoHolesBuf", driver="ESRI Shapefile")
t1 = gBuffer(noHoles, byid=TRUE, width=100.0, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
# testedHoles.df = data.frame("ID" = unique(testingHoles@data$IDNP))
# rownames(testedHoles.df) = testedHoles.df$ID
# withHoles <- SpatialPolygonsDataFrame(testedHoles, testedHoles.df)
#
# t1@polygons[[2]]@ID
# REG@polygons[[i]]@ID)
# plot(t1, border=F, col="red")
#
# pc100km <- gBuffer( pc, width=100*distm, byid=TRUE )
# # Add data, and write to shapefile
# pc100km <- SpatialPolygonsDataFrame( pc100km, data=pc100km@data )
# writeOGR( pc100km, "pc100km", "pc100km", driver="ESRI Shapefile" )
writeOGR(t1, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf2.shp",
layer = "clusters_NoHolesBuf2", driver="ESRI Shapefile")
t2 = unionSpatialPolygons(t1)
length(t1)
t2 = unionSpatialPolygons(t1, IDs = 1:length(t1))
writeOGR(t2, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf3.shp",
layer = "clusters_NoHolesBuf3", driver="ESRI Shapefile")
length(t2)
t3 <- SpatialPolygonsDataFrame(t2, data.frame("ID" = 1:length(t2)))
writeOGR(t3, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf3.shp",
layer = "clusters_NoHolesBuf3", driver="ESRI Shapefile")
over(t3)
t2 = unionSpatialPolygons(t1, IDs = 1:length(t1))
plot(t2)
plot(t2, col = red, border=F)
plot(t2, col = "red", border=F)
t1 = gBuffer(noHoles, width=100.0, capStyle="ROUND",
joinStyle="ROUND")
t2 = disaggregate(t1)
writeOGR(t2, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf4.shp",
layer = "clusters_NoHolesBuf4", driver="ESRI Shapefile")
t2 = SpatialPolygonsDataFrame(t2, data.frame("ID" = 1:length(t2)))
writeOGR(t2, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf4.shp",
layer = "clusters_NoHolesBuf4", driver="ESRI Shapefile")
t2b = dropHole(t2)
writeOGR(t2b, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf4.shp",
layer = "clusters_NoHolesBuf4", driver="ESRI Shapefile")
t1 = gBuffer(noHoles, width=1000.0, capStyle="ROUND",
joinStyle="ROUND")
t2 = disaggregate(t1)
t2 = SpatialPolygonsDataFrame(t2, data.frame("ID" = 1:length(t2)))
t2b = dropHole(t2)
writeOGR(t2b, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf5.shp",
layer = "clusters_NoHolesBuf5", driver="ESRI Shapefile")
t1 = gBuffer(noHoles, width=200.0, capStyle="ROUND",
joinStyle="ROUND")
t2 = disaggregate(t1)
t2 = SpatialPolygonsDataFrame(t2, data.frame("ID" = 1:length(t2)))
t2b = dropHole(t2)
writeOGR(t2b, "/Users/clementinecottineau/Documents/clementine/UKRDRF/GIS/clusters_NoHolesBuf6.shp",
layer = "clusters_NoHolesBuf6", driver="ESRI Shapefile")
plot(t2b)
plot(t2b, borders=F, col="red")
plot(t2b, border=F, col="red")
plot(wpp)
pi <- intersect(t2b, wpp)
shiny::runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
runApp('Documents/MetaZipf')
refs = read.csv("data/zipf_refs.csv", sep=",", dec=".")
setwd("~/Documents/MetaZipf")
meta = read.csv("data/zipf_meta.csv", sep=",", dec=".")
meta$TOTAL_POP = as.numeric(meta$TOTAL_POP)
meta[meta$ECO == 1 & meta$SOC == 0 & meta$PHYS == 0, "DISCIPLINE"] = "ECO"
meta[meta$ECO == 1 & meta$SOC == 1 & meta$PHYS == 0, "DISCIPLINE"] = "ECO & SOC"
meta[meta$ECO == 1 & meta$SOC == 0 & meta$PHYS == 1, "DISCIPLINE"] = "ECO & PHYS"
meta[meta$ECO == 1 & meta$SOC == 1 & meta$PHYS == 1, "DISCIPLINE"] = "ECO, SOC & PHYS"
meta[meta$ECO == 0 & meta$SOC == 1 & meta$PHYS == 0, "DISCIPLINE"] = "SOC"
meta[meta$ECO == 0 & meta$SOC == 1 & meta$PHYS == 1, "DISCIPLINE"] = "SOC & PHYS"
meta[meta$ECO == 0 & meta$SOC == 0 & meta$PHYS == 1, "DISCIPLINE"] = "PHYS"
refs = read.csv("data/zipf_refs.csv", sep=",", dec=".")
head(refs)
head(meta)
meta = read.csv("data/zipf_meta.csv", sep=",", dec=".")
meta2 = data.frame(meta, refs[match(meta$REFID,refs$REFID),])
head(meta2)
meta[,c("REFID.1", "REGRESSIONFORM", "AUTHOR", "YEAR", "PAGE", "SOURCE")] = NULL
meta0[,c("REFID.1", "REGRESSIONFORM", "AUTHOR", "YEAR", "PAGE", "SOURCE")] = NULL
meta2[,c("REFID.1", "REGRESSIONFORM", "AUTHOR", "YEAR", "PAGE", "SOURCE")] = NULL
rownames(meta2) = 1:dim(meta2)[2]
dim(meta2)[2]
rownames(meta2) = 1:dim(meta2)[1]
meta2[,c("REFID.1", "REGRESSIONFORM", "AUTHOR", "YEAR", "PAGE", "SOURCE")] = NULL
meta2$REFID.1 = NULL
meta = read.csv("data/zipf_meta.csv", sep=",", dec=".")
meta$TOTAL_POP = as.numeric(meta$TOTAL_POP)
refs = read.csv("data/zipf_refs.csv", sep=",", dec=".")
head(meta)
metaToAdd = data.frame()
refsToAdd = data.frame()
meta = data.frame(meta, refs[match(meta$REFID,refs$REFID),])
rownames(meta) = 1:dim(meta)[1]
meta$REFID.1 = NULL
meta$REGRESSIONFORM = NULL
meta$AUTHOR = NULL
meta$YEAR = NULL
meta$PAGE = NULL
meta$SOURCE = NULL
meta[meta$ECO == 1 & meta$SOC == 0 & meta$PHYS == 0, "DISCIPLINE"] = "ECO"
meta[meta$ECO == 1 & meta$SOC == 1 & meta$PHYS == 0, "DISCIPLINE"] = "ECO & SOC"
meta[meta$ECO == 1 & meta$SOC == 0 & meta$PHYS == 1, "DISCIPLINE"] = "ECO & PHYS"
meta[meta$ECO == 1 & meta$SOC == 1 & meta$PHYS == 1, "DISCIPLINE"] = "ECO, SOC & PHYS"
meta[meta$ECO == 0 & meta$SOC == 1 & meta$PHYS == 0, "DISCIPLINE"] = "SOC"
meta[meta$ECO == 0 & meta$SOC == 1 & meta$PHYS == 1, "DISCIPLINE"] = "SOC & PHYS"
meta[meta$ECO == 0 & meta$SOC == 0 & meta$PHYS == 1, "DISCIPLINE"] = "PHYS"
runApp()
runApp()
runApp()
>>>>>>> a8a55708ea50cff0665255a578d62142bd587896
